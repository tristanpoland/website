<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,target-densitydpi=device-dpi">
<meta name="generator" content="verse">
<meta name="X-UA-Compatible" content="IE=edge">


<title>Genesis</title>


<link rel="icon" href="/favicon.ico">
<link rel="stylesheet" href="/css/libs.css?6">
<link rel="stylesheet" href="/css/main.css?6">
<link rel="stylesheet" href="/css/extra.css?6">
<link rel="alternate home" type="application/rss+xml" title="Genesis - RSS feed" href="/feed.xml">
</head>
<body class="dark-load">
	<header id="top-nav" class="top-nav page-header">
		<div class="container">
			<a class="logo smooth-scroll" href="/">
				<img class="logo-white" alt="Stark & Wayne" src="/img/logo.png?6" />
			</a>
			<nav class="top-menu">
				<ul class="sf-menu">
					<li><a href="/">Home</a></li>
            <!--<li><a href="/blog">Blog</a></li>-->
					<li><a href="/download">Download</a></li>
					<li><a href="/community">Community</a></li>
					<li><a href="/docs/getting-started">Docs</a></li>
          <!--<li><a href="/dev">Developers</a></li>-->
				</ul>
			</nav>
			<div id="mobile-menu">
				<div class="inner-wrap">
					<nav>
						<ul class="nav_menu">
							<li><a href="/">Home</a></li>
							<li><a href="/download">Download</a></li>
							<li><a href="/docs">Documentation</a></li>
              <!--<li><a href="/dev">Developers</a></li>-->
						</ul>
					</nav>
				</div>
			</div>
		</div>
	</header>

	<section id="top" class="display-page img-parallax bg-mask background-image"
                  data-image="/img/hbg.jpg">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <h1>The Genesis Blog</h1>
      </div>
    </div>
  </div>
</section>

<section class="page article">
  <div id="container" class="container">
    
    <div class="row">
      <div class="col-md-8 col-md-push-2">
        <div class="content"><article>
          <div class="header">
            
            <h1>Installing the Genesis Toolchain on Linux</h1>
            <p class="dated">Thursday, August  1, 2019</p>
          </div>
          <p>There are a series of tools you'll need in order to work with Genesis. This is
a compilation of how to download and install each of those tools. Most of these
are static Go binaries, and therefore usually only require downloading the
binary and putting it into your path.</p>

<h2>Table of Contents</h2>

<ul>
<li><a href="#genesis-bosh-spruce-and-safe">genesis, bosh, spruce, and safe</a></li>
<li><a href="#jq">jq</a></li>
<li><a href="#vault">vault</a></li>
<li><a href="#cf">cf</a></li>
<li><a href="#git">git</a></li>
<li><a href="#build-tools">build tools</a></li>
</ul>

<p><a name="genesis-bosh-spruce-and-safe"></a></p>

<h2>Genesis, BOSH, Spruce, and Safe</h2>

<p><code>
wget -q -O - https://raw.githubusercontent.com/starkandwayne/homebrew-cf/master/public.key | sudo apt-key add -
echo "deb http://apt.starkandwayne.com stable main" | sudo tee /etc/apt/sources.list.d/starkandwayne.list
sudo apt-get update
sudo apt-get install genesis
</code></p>

<p><a name="jq"></a></p>

<h2>jq</h2>

<p><code>
sudo apt-get install jq
</code></p>

<p><a name="vault"></a></p>

<h2>Vault</h2>

<p>The genesis installation installs a version of Vault, but it installs it from the apt
package which is very old. </p>

<p>Determine the most recent version of Vault from:</p>

<p>https://www.vaultproject.io/downloads.html</p>

<p>Set the <code>LATEST_VAULT_VERSION</code> environment variable as shown below and run the following commands:</p>

<p><code>
export LATEST_VAULT_VERSION=1.1.3
wget "https://releases.hashicorp.com/vault/${LATEST_VAULT_VERSION}/vault_${LATEST_VAULT_VERSION}_linux_amd64.zip"
sudo apt-get update
sudo apt-get install unzip
sudo unzip "vault_${LATEST_VAULT_VERSION}_linux_amd64.zip" -d /usr/local/bin
sudo chmod 0777 /usr/local/bin/vault
</code></p>

<p><a name="cf"></a></p>

<h2>CF</h2>

<p>While CF is not strictly required by Genesis, there's a good chance that if
you're using Genesis, you're looking at using Cloud Foundry.</p>

<p><code>
wget -q -O - https://packages.cloudfoundry.org/debian/cli.cloudfoundry.org.key | sudo apt-key add -
echo "deb https://packages.cloudfoundry.org/debian stable main" | sudo tee /etc/apt/sources.list.d/cloudfoundry-cli.list
sudo apt-get update
sudo apt-get install cf-cli
</code></p>

<p><a name="git"></a></p>

<h2>Git</h2>

<p>You likely already have Git installed on whatever Linux box you're on. This section is a reminder
that you'll need to configure your email and name with Git in order to use it. Genesis requires
that git is configured in order to initialize a new deployment directory.</p>

<p>You'll need to run:</p>

<p><code>
git config --global user.name "Your Name"
git config --global user.email "Your Email"
</code></p>

<p><a name="build-tools"></a></p>

<h2>Build Tools</h2>

<p>Your system may not have a C compiler installed by default. You'll need this in order to compile
packages for your proto BOSH. You can get the compiler tools from apt:</p>

<p><code>
sudo apt-get update &amp;&amp; \
sudo apt-get install \
    build-essential \
    zlibc \
    zlib1g-dev \
    ruby \
    ruby-dev \
    openssl \
    libssl-dev \
</code></p>
        </article></div>
      </div>
      
    <div class="row">
      <div class="col-md-8 col-md-push-2">
        <div class="content"><article>
          <div class="header">
            
            <h1>Deploying a BOSH to Microsoft Azure Using Genesis and Terraform</h1>
            <p class="dated">Thursday, August  1, 2019</p>
          </div>
          <h2>Table of Contents</h2>

<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#getting-automation-credentials">Getting Automation Credentials</a></li>
<li><a href="#setting-up-terraform">Setting Up Terraform</a></li>
<li><a href="#setting-up-your-bastion-host">Setting Up Your Bastion Host</a></li>
<li><a href="#starting-a-local-vault-instance">Starting a Local Vault Instance</a></li>
<li><a href="#deploying-a-new-proto-bosh">Deploying a New Proto-BOSH</a></li>
<li><a href="#logging-into-bosh">Logging Into BOSH</a></li>
<li><a href="#generating-and-uploading-a-cloud-config">Generating and Uploading a Cloud Config</a></li>
<li><a href="#next-steps">Next Steps</a></li>
</ul>

<p><a name="introduction"></a></p>

<h2>Introduction</h2>

<p>BOSH can be an effective way to manage your infrastructure, but before you
have a BOSH director, you've got to bootstrap your infrastructure to a point
where you can deploy a BOSH Director to it. In this post, we'll cover setting
up an automation account, using Terraform to configure Azure all the way up
to making a network for your new BOSH director, and using Genesis to quickly
configure and deploy your BOSH director.</p>

<p><a name="prerequisites"></a></p>

<h2>Prerequisites</h2>

<p>This post does not cover the installation of the Genesis toolchain (genesis,
spruce, etc.). It is expected that you have these things installed already.</p>

<p>You'll need to create your own Azure account and subscription (or have your
organization create one for you). Your account will need ownership privilege
over the subscription in order to make automation credentials. If you don't
have these privileges, you'll need somebody to take the steps in the next
section for you.</p>

<p><a name="getting-automation-credentials"></a></p>

<h2>Getting Automation Credentials</h2>

<p>App registrations in Azure are automation accounts. We're going to need one of
these so that Terraform and BOSH can authenticate and manipulate resources. To
create one, first log in to the Azure portal (portal.azure.com).</p>

<p>Once logged in, navigate to the <code>Azure Active Directory</code> on your sidebar. This
presents a new sidebar, on which you should navigate to <code>App registrations</code>.
This will open up yet another bar - this time a horizontal one - and you should
click on <code>New registration</code> therein.</p>

<p>Now you have a small form to complete. It will ask you to provide a display
name for the application, the account type, and a redirect URI. The display
name can be whatever you want it to be. The account type will almost always
be set to <code>Accounts in this organizational directory only</code>, and the redirect
URI can be left blank for our use cases. The Redirect URI type can be set to
web.</p>

<p>Once you apply the settings, you should be brought to the app's overview page.
If you should navigate away for any reason, you can come back to this page by
finding it in the list of app registrations in the Azure Active Directory panel.
This page contains a few pieces of information we need. To authenticate as an
application, we need a set of credentials that Azure refers to as a "service
principal". This includes the following:</p>

<ul>
<li>Application ID</li>
<li>Client Secret</li>
<li>Tenant ID</li>
</ul>

<p>This page contains the application ID and tenant ID. Take note of them, and
then navigate to <code>Certificates &amp; secrets</code>. Create a new client secret; set the
expiry to something you're comfortable with (secrets can be rotated at a later
time). Then, take the output value and note that down as well.</p>

<p>We will also need the ID of the subscription that resources will be created in
(and billed to). To find the ID, search <code>Subscriptions</code> in the top bar, go to
the list of subscriptions and select the desired subscription from the list.
Copy the ID and note it down.</p>

<p>While you're still on the subscription page, you can give the application
you created access to create resources in the target subscription. To d
so, click on <code>Access Control (IAM)</code> on the sidebar, and then <code>Add a role
assignment</code>. Search for and select the name of the application you previously
created, and give it the role of <code>Contributor</code>.</p>

<p><a name="setting-up-terraform"></a></p>

<h2>Setting up Terraform</h2>

<p>Now that we have automation credentials, we can start standing up
infrastructure using Terraform. Terraform binaries and documentation can be
found at <a href="https://terraform.io">https://terraform.io</a>.</p>

<p>We've already made a basic Terraform file for you that can stand up your
control plane if given a few extra parameters. You can find that file
<a href="https://github.com/genesis-community/terraforms/tree/master/controlplane/azure">here</a>.</p>

<p>There is also a <code>terraform.tfvars.example</code> file in that directory that can be
used as a basis for creating your <code>terraform.tfvars</code> file. It contains all of
the possible parameters you can specify for your deployment.</p>

<p>The <code>subscription_id</code>, <code>tenant_id</code>, <code>client_id</code>, and <code>client_secret</code> were all
values that you should have taken note of while making your app registration.
The <code>resource_group_name</code> is the name of the resource group that you'd like
Terraform to create. </p>

<p>The <code>location</code> is the Azure location that you wish resources to be created in. </p>

<p>The <code>starting_address</code> is the first address of a <code>/16</code> range you'd like the
network to use. Try to select a range that isn't in use elsewhere in your
subscription, in case you ever decide to peer the networks.</p>

<p><code>dns_servers</code> are the default dns servers that will be used by resources in the
network. By default, its set to use the public Cloudflare servers.</p>

<p><code>ssh_keys</code> are the public keys that will be put on in the <code>authorized_keys</code>
file of the bastion box that gets created. You'll need to provide one in order
to log in.</p>

<p>Once configured, run the following from the directory with your <code>azure.tf</code> and
<code>terraform.tfvars</code> file.</p>

<p><code>
terraform apply
</code></p>

<p>Take note of the output variables after a successful apply, as they contain the
answers to many of the questions that Genesis will ask you later.</p>

<p><a name="setting-up-your-bastion-host"></a></p>

<h2>Setting Up Your Bastion Host</h2>

<p>Once your bastion box is created, you should be able to ssh into it if you
configured your Terraform file properly. Once inside, you'll need to install
the tools needed for Genesis. For instructions on how to install these tools,
see <a href="https://github.com/genesis-community/website/blob/master/blogs/toolchain/install.md">this document</a>.</p>

<p><a name="starting-a-local-vault-instance"></a></p>

<h2>Starting a Local Vault Instance</h2>

<p>We use the <a href="https://github.com/starkandwayne/safe">Safe CLI</a> to interact with
Vault in general. You should have it installed after after following the
instructions on setting up your bastion host. We're going to use Safe to
quickly set up a temporary local Vault instance that Genesis can use until we
are able to set up a permanent Vault through BOSH at a later time.</p>

<p>To do this, open a separate shell session / tmux pane on the jumpbox and run </p>

<p><code>
safe local --memory
</code></p>

<p>Safe will output the target name of the new Vault, target it, and authenticate
to it automatically.</p>

<p><a name="deploying-a-new-proto-bosh"></a></p>

<h2>Deploying a New Proto-BOSH</h2>

<p>Navigate to the directory in which you would like to store the Genesis
deployment directory and run </p>

<p><code>
genesis init bosh -k bosh
</code></p>

<p>Newer versions of genesis will prompt you at this point about which Vault
you would like to use. Select the target that was created by <code>safe local</code>.</p>

<p><code>cd</code> into the newly created directory. Now we need to tell Genesis to
initialize the configuration file for a new proto-BOSH director deployment.
Decide what you would like to call this environment. We typically recommend
an <code>&lt;org&gt;-&lt;site&gt;-&lt;env&gt;</code> naming scheme. I'll call mine <code>snw-eastus-controlplane</code>.
Once this is determined, run <code>genesis new</code> with the environment name.</p>

<p><code>
genesis new snw-eastus-controlplane
</code></p>

<p>You'll now be walked through a series of questions about the deployment you're
about to make. The prompts will look something like the following:</p>

<p>```
ubuntu@bastion:~/deployments/bosh-deployments$ genesis new snw-eastus-controlplane
Setting up new environment snw-eastus-controlplane...</p>

<p>Using vault at http://127.0.0.1:8201.
Verifying availability...ok</p>

<p>Is this a proto-BOSH director?
[y|n] > y</p>

<p>What static IP do you want to deploy this BOSH director on?</p>

<blockquote>
  <p>10.0.0.5</p>
</blockquote>

<p>What network should this BOSH director exist in (in CIDR notation)?</p>

<blockquote>
  <p>10.0.0.0/24</p>
</blockquote>

<p>What default gateway (IP address) should this BOSH director use?</p>

<blockquote>
  <p>10.0.0.1</p>
</blockquote>

<p>What DNS servers should BOSH use? (leave value empty to end)
1st value > 1.1.1.1
2nd value > 1.0.0.1
3rd value ></p>

<p>What IaaS will this BOSH director orchestrate?
  1) VMWare vSphere
  2) Amazon Web Services
  3) Microsoft Azure
  4) Google Cloud Platform
  5) OpenStack
  6) BOSH Warden</p>

<p>Select choice > Microsoft Azure</p>

<p>What is your Azure Client ID?</p>

<blockquote>
  <p>01234567-89ab-cdef-0123-456789abcdef
What is your Azure Client Secret?
client<em>secret [hidden]:
client</em>secret [confirm]:</p>
</blockquote>

<p>What is your Azure Tenant ID?</p>

<blockquote>
  <p>01234567-89ab-cdef-0123-456789abcdef</p>
</blockquote>

<p>What is your Azure Subscription ID?</p>

<blockquote>
  <p>01234567-89ab-cdef-0123-456789abcdef</p>
</blockquote>

<p>What Azure Resource Group will BOSH be deploying VMs into?</p>

<blockquote>
  <p>genesis</p>
</blockquote>

<p>What security group should be used as the BOSH default security group?</p>

<blockquote>
  <p>genesis-sg</p>
</blockquote>

<p>What is the name of your Azure Virtual Network?</p>

<blockquote>
  <p>genesis-network</p>
</blockquote>

<p>What is the name of the Azure subnet that the BOSH will be placed in?</p>

<blockquote>
  <p>genesis-controlplane-subnet</p>
</blockquote>

<p>Would you like to edit the environment file?
[y|n] > n
 - auto-generating credentials (in secret/snw/eastus/controlplane/bosh)...
 - auto-generating certificates (in secret/snw/eastus/controlplane/bosh)...
New environment snw-eastus-controlplane provisioned!</p>

<p>To deploy, run this:</p>

<p>genesis deploy 'snw-eastus-controlplane'</p>

<p>```</p>

<p>Of note, if this is your first BOSH, then this <em>is</em> a Proto-BOSH director.
Also, if you've read this far, the IaaS you're targeting is likely Microsoft
Azure. The remaining answers can be found in the outputs of your Terraform
apply or in your <code>terraform.tfvars</code> file.</p>

<p>The command will then spend some time generating certificates and secrets for
the deployment to use. These will get stored in the Vault and made accessible
by the <code>safe</code> utility.</p>

<p>An environment file named after your environment name (e.g.
<code>snw-eastus-controlplane.yml</code>) will be created. This contains all non-sensitive
information about your deployment. It is safe to store in version control. If
you needed to change anything about your deployment, you would make your changes
in this file. For the purpose of this tutorial, we will assume that the defaults
are fine and that you don't need to make changes to this file.</p>

<p>You should now be able to run</p>

<p><code>
genesis deploy snw-eastus-controlplane
</code></p>

<p>Substitute <code>snw-eastus-controlplane</code> with the name of your environment (the
argument you gave to <code>genesis new</code>). Genesis should handle the rest of the
deployment for you.</p>

<p><a name="logging-into-bosh"></a></p>

<h2>Logging Into BOSH</h2>

<p>To log in to the BOSH director, you can run:</p>

<p><code>
genesis do snw-eastus-controlplane -- alias
genesis do snw-eastus-controlplane -- login
</code></p>

<p>Substitute snw-eastus-controlplane with your own environment name.</p>

<p><a name="generating-and-uploading-a-cloud-config"></a></p>

<h2>Generating and Uploading a Cloud Config</h2>

<p>The BOSH cloud config contains shared information about all the deployments
you'll be deploying to your control plane environment. This includes the
network IP allocations, VM sizes, disk sizes, availability zone configurations,
and compilation VM configuration.</p>

<p>We've provided a spruce file which, when merged with a YAML configuration file,
will generate a working cloud config for you. Take the <code>cloud_config.yml</code> file
from the 
<a href="https://github.com/genesis-community/terraforms/tree/master/controlplane/azure">terraform repo</a>
and copy it into a temporary location on your jumpbox. Call this copy
<code>cloud_config.yml</code> as well. Also copy the <code>cloud_config_meta.yml.example</code> file
into a file called <code>cloud_config_meta.yml</code>. That file should look something
like this:</p>

<p><code>yml
meta:
  vnet:
    name: genesis-network
  subnet:
    name: genesis-subnet
  dns_servers:
  - 1.1.1.1
  - 1.0.0.1
  ip_prefix: "10.0.0."
</code></p>

<p>The values need to be changed to match your Azure configuration.
<code>meta.vnet.name</code> and <code>meta.subnet.name</code> are the name of your Azure virtual
network and subnet as printed out by Terraform, respectively.
<code>meta.dns_servers</code> is the array of DNS servers you configured that were also
output by Terraform.</p>

<p><code>meta.ip_prefix</code> is a bit of a kludge due to limitations in how spruce works.
Give it the first three octets of the network address of your controlplane
subnet, ending with a <code>.</code>.</p>

<p>Once that's put together, run </p>

<p><code>
mkdir director-configs
spruce merge --prune meta cloud_config.yml cloud_config_meta.yml &gt; director-configs/controlplane.yml
</code></p>

<p>Put that output <code>controlplane.yml</code> file into a place where you'd like to keep
the offline versions of your BOSH cloud configs (preferably in a Git repo).</p>

<p>Make sure that you're logged into bosh. Then run</p>

<p><code>
bosh -e snw-eastus-controlplane update-cloud-config controlplane.yml
</code></p>

<p>Where <code>snw-eastus-controlplane</code> is whatever you called your controlplane
environment. Now your cloud config should be uploaded and ready to go.</p>

<p><a name="next-steps"></a></p>

<h2>Next Steps</h2>

<p>If you're building out a full environment, at this point you should be looking
to deploy a permanent Vault. With your new BOSH. We're working on making a document
on this in-particular, and this section will be updated with a link to that once it
is completed.</p>
        </article></div>
      </div>
      
    <div class="row">
      <div class="col-md-8 col-md-push-2">
        <div class="content"><article>
          <div class="header">
            
              <img src="/blog/header/francesco-gallaroti-72602.jpg" />
              
              <cite><a href="https://unsplash.com/@gallarotti">Francesco Gallarotti (@gallarotti), via Unsplash</a></cite>
              
            
            <h1>Building a Genesis Lab in AWS (Part I)</h1>
            <p class="dated">Friday, November  9, 2018</p>
          </div>
          <p>Everybody needs a place to play, to experiment, and to try wacky things
with new technology.  It's the same when you're just getting started with
Genesis &mdash; you need a lab environment!</p>

<p><aside><p><strong>Note:</strong> this is the first in a
series of blog posts on the topic of creating labs in AWS.  Check back in
the next few weeks for the rest of the series.</p></aside></p>

<p>For this to work, you're going to need an Amazon Web Services (AWS) account,
both parts of an Amazon Access Key ID / Secret Access Key set, and an EC2
(SSH) key pair (which we can generate).</p>

<h2>First Things First: Terraform</h2>

<p>We've just released <a href="https://github.com/genesis-community/terraforms">Genesis Terraforms</a>, a (hopefully growing)
collection of purpose-built Terraform configurations that make it easy to
spin up different bits of cloud infrastructure, on different providers.
Want a production operations tier on GCP?  Genesis Terraforms.  Want to
train a bunch of people on Concourse?  Genesis Terraforms.  Trying to follow
along in a blog post about setting up a lab in AWS?  Genesis Terraforms.</p>

<p>First, you're going to want to clone the git repository.</p>

<pre><code>$ git clone https://github.com/genesis-community/terraforms
</code></pre>

<p>The particular configuration we'll be targeting is in the <code>lab/aws</code>
sub-directory.  It requires a few variables, so we'll have to create an
<code>aws.tfvars</code> file inside there.</p>

<pre><code>$ cd terraforms/lab/aws
$ vim aws.tfvars
</code></pre>

<p>Your <code>tfvars</code> file will look something like this:</p>

<pre><code>aws_access_key = "AKI..."
aws_secret_key = ".. your actual secret key ..."
aws_vpc_name   = "jhunt-genesis-lab1"
aws_key_name   = "jhunt-genesis-lab1"
aws_key_file   = "jhunt-genesis-lab1.pem"
</code></pre>

<p>(I'll be flattered if you name your first-deployed VPC after me, really I
will.)</p>

<p>The Access Key and Secret Key will be unique to you.  You can set the VPC
name to anything you want; I like to make mine descriptive so I know what I
can and cannot delete in the AWS console.</p>

<p>That <code>aws_key_file</code> needs to be set to the path of the EC2 key pair's
private key component.  If you don't already have one of these, they are
easy enough to generate in the AWS console.  You may want to refer to these
<a href="https://github.com/genesis-community/terraforms/tree/master/lab/aws#deploying-an-aws-lab">step-by-step instructions</a>.</p>

<p>Once you've got all that, command the combined power of a thousand robots
with this one simple incantation:</p>

<pre><code>$ make
</code></pre>

<p>That will compile the Terraform plan, taking into account the variables we
just set, and provide you a summary of what is to be done to AWS.  Type
"yes" when prompted and Terraform will go off and deploy a VPC, some
subnets, security groups, a Linux bastion host with an elastic IP, and some
other stuff.</p>

<p>When that's all settled, you should see this:</p>

<pre><code>Apply complete! Resources: 12 added, 0 changed, 0 destroyed.

... some more output ...

For configuring your proto-BOSH:

  Static IP:       10.4.0.4
  Range (CIDR):    10.4.0.0/24
  Gateway:         10.4.0.1
  DNS:             10.4.0.2

  AWS Region:      us-west-2
  VM Sec. Group:   open-lab
  BOSH Sec. Group: open-lab
  Subnet ID:       subnet-07c0644b5296640a9

To access the bastion host:

  ssh -i jhunt-genesis-lab1.pem ubuntu@some.ip.addr.ess
</code></pre>

<p>Congratulations, you've successfully configured all the IaaS bits!</p>

<h2>Understanding the Lab Topology</h2>

<p>So what have we just deployed?  It looks a little something like this:</p>

<p><img class="full border" src="/blog/aws-lab-1/topology.png"></p>

<p>There are two networks, <strong>DMZ</strong> and <strong>Lab</strong>, which appropriate gateways and
NAT devices to make the Internet traffic work.  Inside the DMZ network
(a 10.4.255.192/26), we have a <strong>bastion host</strong>, which has a public IPv4
address.  This is how we'll get into the VPC to administer it, configure
BOSH, run <code>genesis</code> commands, etc.</p>

<p>The two networks can see each other completely; traffic from the DMZ can
pass freely into the interior Lab network, and vice-versa.  Since we're
testing, the security groups are wide-open and the network ACLs (that
firewall out front) are virtually not there.</p>

<p>From the bastion host, we will deploy our (proto-)BOSH director into the Lab
network, and use that BOSH director to deploy our Vault node(s), and
anything else that strikes our fancy.</p>

<h2>Settling Into the Bastion Host</h2>

<p>The bastion host has all the software you need to run Genesis, including
Spruce, Vault, the BOSH and CF CLIs, and, of course, <code>genesis</code> itself.</p>

<p><aside><p><strong>Note:</strong> if you ever forget how the IP address of
your bastion host, and don't want to log into the AWS web console to find
out, you can just run</p>

<pre><code>$ make info</code></pre>

<p>To print out the information you got at the end of the initial
Terraforming.</p></aside></p>

<p>The first time you log into the bastion, you're going to have to do a little
bit of configuration.</p>

<pre><code>$ sudo jumpbox system
</code></pre>

<p>The first command sets up global jumpbox-y things.  It installs a slew of
useful utilities like <a href="https://github.com/starkandwayne/safe">safe</a>, <a href="https://github.com/geofffranks/spruce">spruce</a>, <a href="https://github.com/stedolan/jq">jq</a>, and more.
It also installs required commands like <code>bosh</code>, <code>cf</code>, and <code>genesis</code>.</p>

<p>To see what's installed, just run <code>jumpbox</code> with no arguments.</p>

<pre><code>$ jumpbox
&gt;&gt; Checking jumpbox installation
   jumpbox installed - jumpbox v55
   ruby installed - ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-linux-gnu]
   bosh installed - version 3.0.1-712bfd7-2018-03-13T23:26:43Z
   cf installed - cf version 6.40.1+85d04488a.2018-10-31
   jq installed - jq-1.5
   spruce installed - spruce - Version 1.18.2
   safe installed - safe v0.9.9
   vault installed - Vault v0.9.6 ('7e1fbde40afee241f81ef08700e7987d86fc7242')
   genesis installed - Genesis v2.6.12 (563bd7a7ee) build 20180926.165834
   sipcalc installed - sipcalc 1.1.6

   git user.name  is 'James Hunt'
   git user.email is 'jhunt@starkandwayne.com'

   To bootstrap this installation,  try `jumpbox system`
   To set up your personal environment: `jumpbox user`
   To update this copy of jumpbox, use: `jumpbox sync`
   To create a new local user account:  `jumpbox useradd`
</code></pre>

<h2>The Joys of Terminal Multiplexing</h2>

<p>One final note before we jump into BOSH and Genesis: <code>tmux</code> is an amazing
piece of software.</p>

<p>It's a terminal multiplexer that lets you run lots of terminal sessions,
across a single SSH link.  If you get disconnected, have to reboot your
laptop, or just want to unplug for a long weekend, your tmux session will
still hum along happily on the remote server.</p>

<p>To use tmux, just run <code>tmux</code> from the bastion host (that's important!)</p>

<p>It should look something like this:</p>

<p><img class="full" src="/blog/aws-lab-1/tmux.png"></p>

<p>For the rest of this article, I'm going to assume you're doing everything
from a tmux session.  There's a <a href="https://jameshunt.us/writings/my-tmux-cheat-sheet.html">tmux cheat sheet</a> out there if you
aren't 100% comfortable in tmux.</p>

<h2>Running a Local Vault</h2>

<p>Genesis leverages <a href="https://vaultproject.io">Hashicorp Vault</a> to generate and securely store
passwords, SSH keys, X.509 certificates and more.  Once we get a BOSH
director up and running (our very next task, actually), we will use it to
deploy a Vault instance.  Until we get that far, however, we need an
<em>initial</em> Vault to jumpstart the process.</p>

<p>This is where <code>safe</code> proves valuable.</p>

<p>Safe (an alternative command-line interface for Vault) provides the means to
run a local Vault instance, on loopback.  It's so easy, we won't have to
worry about configuration, process management, or unsealing / initializing
our nascent Vault.</p>

<p>So, without further ado:</p>

<pre><code>$ safe local --memory --as init
Now targeting (temporary) init at http://127.0.0.1:8201
This Vault is MEMORY-BACKED!
If you want to retain your secrets be sure to safe export.
Ctrl-C to shut down the Vault
</code></pre>

<p>This gives us a <em>memory-backed</em> Vault, named <code>init</code>.  If we kill the process,
we will lose all the secrets.  That might seem like a bad thing, but we only
really have to get through two deployments (about 2 hours wall time), and
a memory-backed initial Vault won't leak credentials as easily.</p>

<p>Once the local Vault is up and running, we can interact with it via <code>safe</code>:</p>

<pre><code>$ safe tree
$ safe paths
</code></pre>

<p>etc.</p>

<p><aside><p><strong>Remember</strong> to always run the initial Vault inside
of a tmux session.  You don't want to lose all of your credentials just
because you had to close the lid on your laptop and drive home.</p></aside></p>

<h2>Deploying the proto-BOSH</h2>

<p>Before we can begin deploying things with BOSH, we need a BOSH director.
This will be our very first Genesis deployment in this environment, and
we'll use the BOSH <code>create-env</code> tooling (under the hood) to get up and
running.</p>

<p><em>(If you don't know what create-env is, or have never stood up a BOSH
director, don't worry; we'll walk through every step of the process.)</em></p>

<p>In Genesis, a <em>proto-BOSH</em> is the initial deployment.  It is used, in turn,
to deploy both the <em>operations tier</em> (Vault, SHIELD, Concourse, etc.), and
also each of the other <em>environment BOSH directors</em>.  Having BOSH deployed
by another BOSH seems a bit weird at first, but it turns out to be a
surprisingly useful optimization.  For one thing, it makes for faster BOSH
director updates.</p>

<p>To deploy something with Genesis, you need a <em>Kit</em>.  Kits roll up most of
the tedious bits of configuring BOSH releases into usable deployments.  They
can be a bit opinionated at times, but we think that makes for better
software and systems.</p>

<p>Specifically, we are going to use the (unsurprisingly-named) <strong>BOSH Genesis
Kit</strong>.  Since this our first deployment of BOSH, we're going to initialize a
new set of deployments, using <code>genesis init</code> (remember to do this from a
<code>tmux</code> session):</p>

<pre><code>$ mkdir ~/ops
$ cd ~/ops
$ genesis init -k bosh
Downloading Genesis kit bosh (latest version)...

Initialized empty Genesis repository in /home/ubuntu/ops/bosh-deployments
using the bosh/1.2.1 kit.
</code></pre>

<p>The <code>genesis init</code> command creates a <em>deployments</em> directory for the type of
thing you are deploying (in our case, BOSH), and then downloads a Genesis
Kit from GitHub.</p>

<p>Next, we need to write an <em>environment</em> file for our new BOSH director.</p>

<pre><code>$ cd bosh-deployments
$ genesis new jhunt-aws
</code></pre>

<p>Genesis will then ask a whole bunch of (pertinent) questions about your
configuration, infrastructure / cloud provider, and your preferences.
First up, Genesis needs to know what Vault to store your credentials in:</p>

<pre><code>Known Vault targets - current target indicated with a (*):
(*) init         (insecure) http://127.0.0.1:8201

Which Vault would you like to target?
&gt; init
Now targeting init at http://127.0.0.1:8201
</code></pre>

<p>The next question is about <em>proto-BOSH</em> vs. <em>regular BOSH</em>.  We don't yet
have a BOSH director, so we need to deploy a proto-BOSH.  Say "y" here.</p>

<pre><code>Is this a proto-BOSH director?
[y|n] &gt; y
</code></pre>

<p>After that, Genesis asks a series of questions about the networking for this
director.  These answers come from our understanding of the Terraform
configuration we deployed.  You can use these values verbatim.</p>

<pre><code>What static IP do you want to deploy this BOSH director on?
&gt; 10.4.0.4

What network should this BOSH director exist in (in CIDR notation)?
&gt; 10.4.0.0/24

What default gateway (IP address) should this BOSH director use?
&gt; 10.4.0.1

What DNS servers should BOSH use? (leave value empty to end)
1st value &gt; 10.4.0.2
2nd value &gt;
</code></pre>

<p>To properly configure the BOSH director, Genesis needs to know where we are
deploying (what cloud provider / IaaS).  This is AWS, so answer "2".</p>

<pre><code>What IaaS will this BOSH director orchestrate?
1) VMWare vSphere
2) Amazon Web Services
3) Microsoft Azure
4) Google Cloud Platform
5) OpenStack
6) BOSH Warden

Select choice &gt; 2
</code></pre>

<p>Now that Genesis knows we're in Amazon, it can ask more pointed questions
about how we expect the BOSH director to access AWS on our behalf.</p>

<pre><code>What AWS region would you like to deploy to?
&gt; us-west-2

What is your AWS Access Key?
&gt; AKIyourkeyhere...
Now targeting init at http://127.0.0.1:8201

What is your AWS Secret Key?
secret_key [hidden]:
secret_key [confirm]:
</code></pre>

<p>Next up, you will be asked for security groups, and the subnet ID to deploy
the director to.</p>

<pre><code>What security groups should the all deployed VMs be placed in? (leave value
empty to end)
1st value &gt; open-lab
2nd value &gt;

What is the ID of the AWS subnet you want to deploy to?
&gt; subnet-0b79be9eaeb7d164b

What security groups should the BOSH Director VM be in? (leave value empty
to end)
1st value &gt; open-lab
2nd value &gt;
</code></pre>

<p>Hint: you can find the AWS Subnet ID in the output of <code>make info</code>.</p>

<p><em>(The open-lab security group allows all inbound and outbound traffic, on
all ports, to and from all hosts, all protocols.  It won't pass muster on a
production system, but it sure is handy in lab environments.)</em></p>

<p>That concludes the question &amp; answer session.</p>

<p>There is one thing to be done manually in the AWS console, and the Genesis
<code>new</code> wizard helpfully explains the what, why, and how.</p>

<pre><code>Before deploying, please be sure to import the keypair
generated for you from Vault into AWS console.

First run the following command to get the public key:

    safe get secret/jhunt/aws/bosh/aws/ssh:public

Then go to EC2 &gt; Key Pairs &gt; Import Key Pair and:

  1. Type 'vcap@jhunt-aws' in the 'Key pair name' input box
  2. Paste the safe command output into the 'Public key contents' input box
  3. Click 'Import' button

Now you can SSH into VMs deployed by this director
using the generated key.
</code></pre>

<p>So go do that.</p>

<p>Finally, you'll be asked if you want to edit the environment file.  You can
safely say "no" here; we won't be customizing this proto-BOSH.</p>

<p>Now it is Genesis' turn to do some thinking and processing.  You should see
something that looks like this (depending on what you named your
environment):</p>

<pre><code> - auto-generating credentials (in secret/jhunt/aws/bosh)...
 - auto-generating certificates (in secret/jhunt/aws/bosh)...

New environment jhunt-aws provisioned!

To deploy, run this:

  genesis deploy 'jhunt-aws'
</code></pre>

<p>Genesis just generated all of the random passwords and required X.509
certificates that a functioning BOSH director needs.  Isn't that neat?</p>

<p>Literally all you have to do is run that <code>genesis deploy</code> command.</p>

<pre><code>$ genesis deploy jhunt-aws
</code></pre>

<p>When that finishes, follow the on-screen instructions and log into the BOSH
director:</p>

<pre><code>$ genesis do jhunt-aws -- login
Running login addon for jhunt-aws
Logging you in as user 'admin'...
Using environment 'https://10.4.0.4:25555'

Email (): admin
Password ():

Successfully authenticated with UAA

Succeeded
</code></pre>

<h2>Preparing the Director</h2>

<p>The BOSH director is deployed, but before we can use it to deploy something,
we need to do two things.</p>

<ol>
<li>Upload a Xenial Stemcell</li>
<li>Install a valid Cloud Config</li>
</ol>

<h3>Uploading Stemcells</h3>

<p>The BOSH Genesis Kit sports this wonderful addon called <em>upload-stemcells</em>
that provides a menu driven interface for selecting and uploading stemcells
(the stuff deployment VMs are made of).  It properly limits which stemcell
variants are considered, based on the IaaS you configured the director for.</p>

<p>Since we're going to need a stemcell, let's take it for a spin!</p>

<pre><code>$ genesis do jhunt-aws -- upload-stemcells
</code></pre>

<p>This will show you the major and minor versions of the Xenial stemcell
series (Ubuntu 16.04 LTS) for AWS, and let you pick which you want to
upload.  The upload is handed off to the BOSH director, and when you get
back to a prompt you should be good to go.</p>

<p>I tested with Xenial 97.x (latest minor revision).</p>

<h3>Configuring Clouds</h3>

<p>BOSH Cloud Config is one of the more arcane and esoteric parts of BOSH.
To help make this easier, the <strong>Genesis Terraforms</strong> repository can build a
rudimentary, baseline cloud config, if you ask it to.</p>

<p>From wherever you ran the Terraforming process, run:</p>

<pre><code>$ make cc
</code></pre>

<p>That will print out a cloud config YAML document that you can transfer to
the bastion host, and use that to <code>bosh update-cloud-config</code>.</p>

<p>This cloud config defines a <code>default</code> network, some generic VM types (small,
medium, large), a default disk type, and a single availability zone (z1).
It should suffice to get us through the next deployment, and since this is a
lab, you're probably going to modify it eventually anyway!</p>

<h2>Deploying the Vault</h2>

<p>Now that we have a BOSH director, a stemcell, and a cloud config, we can
deploy a real Vault to replace the ephemeral <code>safe local</code> Vault we've been
using up to now.  We'll repeat the same dance of <code>genesis init</code> / <code>genesis
new</code>, only this time, for the <strong>Vault Genesis Kit</strong>.</p>

<pre><code>$ cd ~/ops
$ genesis init -k vault
$ cd vault-deployments
$ genesis new jhunt-aws
</code></pre>

<p>The Vault kit is mercifully less chatty than the BOSH Director kit, so there
isn't much in the way of questions to answer during <code>genesis new</code>.  We will
be asked if this is the <em>Genesis Vault</em>.  It is, so answer "y" to that one.</p>

<p>If you try to deploy the Vault now (go ahead, I'll wait) it will fail,
because the Vault Kit expects to deploy a highly-available cluster across
three different availability zones.  Our lab only has one AZ, so it doesn't
work.</p>

<p>Not a big deal, all we have to do is open up the <code>jhunt-aws.yml</code> file (in
<code>vault-deployments/</code>) in our favorite editor, and add this to the <code>params:</code>
stanza:</p>

<pre><code>params:
  availability_zones: [z1]
  stemcell_os: ubuntu-xenial
</code></pre>

<p>Changing <code>stemcell_os</code> is also necessary, because (at least as of 1.2.1) the
Vault Kit expects to deploy to the latest Ubuntu Trusty (14.04 LTS), but we
only uploaded Xenial stemcells.</p>

<p>Now we can deploy.</p>

<pre><code>$ genesis deploy jhunt-aws
</code></pre>

<p>After the deployment succeeds, we need to initialize the Vault:</p>

<pre><code>$ genesis do jhunt-aws -- init
</code></pre>

<p>This sets up a safe target in your local configuration, named <code>jhunt-aws</code>
(after the environment).  We are now able to transfer all of our
credentials from the ephemeral <code>init</code> Vault to their forever home.</p>

<pre><code>$ safe -T init export | safe -T jhunt-aws import
</code></pre>

<p>It is now safe to kill the <code>safe local</code> process.</p>

<p>Congratulations! </p>

<p class="emoji">ðŸŽ‰</p>

<h2>Neat!  Now What?</h2>

<p>Hopefully you've had fun setting up this little AWS lab.  The BOSH director
we deployed has Credhub installed, so you're able to deploy whatever you
want to it, with or without the power of Genesis.</p>

<p>If you do think Genesis is awesome sauce, check out the other kits and see
if anything tickles your fancy.  Official Genesis Kits live on GitHub, in
the <a href="https://github.com/genesis-community">Genesis Community organization</a>.  Notable Kits include:</p>

<ul>
<li><p><strong><a href="https://github.com/genesis-community/concourse-genesis-kit">Concourse</a></strong> - Deploy a CI/CD pipeline and get started
with automating your Genesis deployments!</p></li>
<li><p><strong><a href="https://github.com/genesis-community/shield-genesis-kit">SHIELD</a></strong> - A data protection solution for the cloud.
Schedule backups and perform restores on databases, key-value stores,
even file systems.</p></li>
<li><p><strong><a href="https://github.com/genesis-community/cf-genesis-kit">Cloud Foundry</a></strong> - The Cloud Foundry PaaS itself.  Now
deployed via Genesis.</p></li>
<li><p><strong><a href="https://github.com/genesis-community/blacksmith-genesis-kit">Blacksmith</a></strong> - Data services, on-demand, leveraging
BOSH.  Available for CF marketplaces and Kubernetes!</p></li>
</ul>

<p><aside><p><strong>Stay Tuned!</strong>  This is the first in a series of
posts about deploying all kinds of things with Genesis.  In the next
article, we'll take your new AWS lab for a spin and deploy
Concourse.</p></aside></p>
        </article></div>
      </div>
      
    <div class="row">
      <div class="col-md-8 col-md-push-2">
        <div class="content"><article>
          <div class="header">
            
              <img src="/blog/header/sam-loyd-360eeb61a0ad.jpg" />
              
              <cite><a href="https://unsplash.com/@samloyd">Sam Loyd (@samloyd), via Unsplash</a></cite>
              
            
            <h1>Debugging BOSH IaaS Issues</h1>
            <p class="dated">Thursday, November  8, 2018</p>
          </div>
          <p>A well-tuned BOSH director is a thing of beauty.  When all the pieces and
parts are humming and clicking properly, everything just works and you start
to forget that provisioning operating systems and software stacks,
especially in the cloud provider of your choice, was ever difficult in the
first place.</p>

<h2>Meet The T3, Same As The T2</h2>

<p>On August 21st, 2018, <a href="https://aws.amazon.com/blogs/aws/new-t3-instances-burstable-cost-effective-performance">Amazon introduced T3</a>, the next round of upgrades
to the T-series of instance types that include the venerable t2.micro, and
the miserly t2.nano.  If you, like me, do a lot of cloud demos and want to
keep costs down, you've probably run into a Tx.something or five.</p>

<p>I just so happened to be sitting down to fire up a lab for installing
Genesis when I saw the announcement, so I decided to take them for a spin.
I was also working through writing <a href="https://github.com/genesis-community/terraforms">distributable Terraform configurations
for Genesis</a> and so I incorporated the T3's into the cloud
configuration template, deployed a VPC, and promptly forgot about the
instance type.</p>

<p>All was not well, however, and my first deployment on the demo BOSH director
was failing to compile packages, with this error:</p>

<pre><code>Task 21 | 14:08:28 | Compiling packages: vault/4f754614313fc27928476ec02e248efd1622c94d (00:15:33)
               L Error: Timed out pinging to 4a320dab-328d-48d0-bd6f-f7776f821b53 after 600 seconds
</code></pre>

<p>We see this a lot when networking is wonky; firewalls, bad NAT
configurations, AWS security groups shenanigans can all cause this.  When
BOSH says it's <em>pinging</em> the instance, it's actually waiting patiently for
the instance to send an "All Good" on the BOSH NATS message bus.</p>

<p>In Amazon, I can use my EC2 SSH key pair to remotely access the instance, as
the <code>vcap</code> user:</p>

<pre><code>SSH_AUTH_SOCK= ssh -i 'vcap@jhunt-aws.pem' vcap@10.4.0.193
</code></pre>

<p>(<code>vcap@jhunt-aws.pem</code> is just what I named the private key file.  I also
unset <code>$SSH_AUTH_SOCK</code> because I have a lot of keys in my SSH agent, and I
don't want to run out of authentication attempts.)</p>

<p>That lets me in just fine.  The instance is clearly being created, and there
are at least no weird networking restrictions between my jumpbox and the
compilation VM.  We need to dig in more.</p>

<p>The next step is to review the BOSH agent logs (in <code>/var/vcap/bosh/logs</code>)
and see what the agent is doing, but to do that I need root privileges.</p>

<pre><code>$ sudo -i
Password for vcap:
</code></pre>

<p>Dang.  So close.  I don't <em>know</em> what the vcap user's password is.
Normally, BOSH randomizes it for each instance it deploys, to help secure
the entire platform.  We need to knock that off for a bit, since it is
interfering with our troubleshooting.</p>

<h2>A Detour To "Soften" The VMs</h2>

<p>To get our sudo back in working order, we have to <em>soften up</em> these VMs a
little bit, in the security department.</p>

<p>First, we are going to need a suitable, <em>encrypted</em> password:</p>

<pre><code>$6$lFvaAqSVJbrigByR$XRtYFRHw2CdNQ54g3sCew5aNpRIrU9gPC8lY8b6ZVM8Er9j16HNyIlJERj4RAPf96p8Ggn/94PUrzEJot0nV4/
</code></pre>

<p>BOSH can set a password for the vcap user, if you give it one in
<a href="https://linux.die.net/man/5/shadow"><code>crypt(3)</code> / <code>shadow(5)</code> format</a>.  In case you don't read the
SHA-512 dialect of crypt, that says "debug".</p>

<p>Now, we just need to inject that into the deployment recipe, via cloud
config.  Because I'm specifically troubleshooting my compilation VMs, I'm
putting this in the <code>compilation:</code> stanza.</p>

<pre><code>compilation:
  #
  # ... the rest of the compilation block ...
  #

  env:
    bosh:
      password: $6$lFvaAqSVJbrigByR$XRtYFRHw2CdNQ54g3sCew5aNpRIrU9gPC8lY8b6ZVM8Er9j16HNyIlJERj4RAPf96p8Ggn/94PUrzEJot0nV4/
</code></pre>

<p>You can also put the <code>env:</code> stuff in your <code>instance_groups:</code> stanza in the
deployment manifest, if you're okay to compile but having similar "pinging"
issues elsewhere.</p>

<p>One re-deploy later, and I'm back on a new (failing) compilation VM,
<strong>ONLY THIS TIME I CAN SUDO!</strong></p>

<pre><code>$ SSH_AUTH_SOCK= ssh -i 'vcap@jhunt-aws.pem' vcap@10.4.0.193
$ sudo -i
Password for vcap: (debug)

# whoami
root
</code></pre>

<p>Now we're getting somewhere.</p>

<h2>Remember that T3?</h2>

<p>Turns out the T3 line <em>is not at all</em> the same as the T2.  Namely, the disk
device names under <code>/dev/</code> are all kinds of different; <code>nvme*</code> instead of
<code>sd*</code>.  My stemcell was too old for that kind of change, and the BOSH agent
was quite insistent on mounting <code>/dev/sdb</code> and <code>/dev/sdf</code>, which just plain
weren't there.</p>

<p>Here's the relevant log snippet, in case it helps:</p>

<pre><code>2018-11-08_15:53:49.01246 [File System] 2018/11/08 15:53:49 DEBUG - Checking if file exists /dev/xvdb
2018-11-08_15:53:49.01248 [File System] 2018/11/08 15:53:49 DEBUG - Stat '/dev/xvdb'
2018-11-08_15:53:49.01248 [File System] 2018/11/08 15:53:49 DEBUG - Checking if file exists /dev/vdb
2018-11-08_15:53:49.01249 [File System] 2018/11/08 15:53:49 DEBUG - Stat '/dev/vdb'
2018-11-08_15:53:49.01249 [File System] 2018/11/08 15:53:49 DEBUG - Checking if file exists /dev/sdb
2018-11-08_15:53:49.01249 [File System] 2018/11/08 15:53:49 DEBUG - Stat '/dev/sdb'
2018-11-08_15:53:49.01298 [unlimitedRetryStrategy] 2018/11/08 15:53:49 DEBUG - Making attempt #271
2018-11-08_15:53:49.01300 [DelayedAuditLogger] 2018/11/08 15:53:49 ERROR - Unix syslog delivery error
2018-11-08_15:53:49.11261 [File System] 2018/11/08 15:53:49 DEBUG - Checking if file exists /dev/xvdb
2018-11-08_15:53:49.11264 [File System] 2018/11/08 15:53:49 DEBUG - Stat '/dev/xvdb'
2018-11-08_15:53:49.11264 [File System] 2018/11/08 15:53:49 DEBUG - Checking if file exists /dev/vdb
2018-11-08_15:53:49.11264 [File System] 2018/11/08 15:53:49 DEBUG - Stat '/dev/vdb'
2018-11-08_15:53:49.11265 [File System] 2018/11/08 15:53:49 DEBUG - Checking if file exists /dev/sdb
2018-11-08_15:53:49.11265 [File System] 2018/11/08 15:53:49 DEBUG - Stat '/dev/sdb'
</code></pre>

<p>Luckily, I was able to get into the compilation VM via SSH, and diagnose the
problem in under two hours.  And the demo lived happily ever after, the end.</p>
        </article></div>
      </div>
      
    </div>
  </div>
</section>

	<footer>
		<div class="container">
			<div class="row">
				<div class="col-md-4">
					<a class="logo" href="https://starkandwayne.com/">
						<img class="logo-white" alt="Stark & Wayne" src="/img/swlogo.png?6" />
						<p><strong>Genesis</strong> is funded and supported by <strong>Stark &amp; Wayne</strong>, the premier BOSH and Cloud Foundry consulting firm.<br>Stark &amp; Wayne: We Know Cloud.</p>
					</a>
				</div>

				<div class="col-md-4">
					<div class="links">
						<h5>Genesis</h5>
						<ul class="list">
							<li><a href="/download">Download Genesis</a></li>
							<li><a href="/docs/getting-started">Getting Started</a></li>
							<li><a href="/community">Community Support</a></li>
						</ul>
					</div>
				</div>

        <!--
				<div class="col-md-4">
					<div class="links">
						<h5>Reference</h5>
						<ul class="list">
							<li><a href="#">Genesis CLI</a></li>
							<li><a href="#">Pipelines</a></li>
							<li><a href="#">Genesis Kits</a></li>
						</ul>
					</div>
				</div>
        -->
			</div>
		</div>

		<div class="down-footer">
			<div class="container">
				<div class="row">
					<div class="col-md-12">
						<p>&copy; 2018 Stark &amp; Wayne.  All Rights Reserved.</p>
						<ul class="footer-menu"></ul>
					</div>
				</div>
			</div>
		</div>
	</footer>

	<!-- FIXME: these don't exist: -->
	<!--[if lt IE 9]>
		<script type="text/javascript" src="/libs/html5shiv/es5-shim.min.js"></script>
		<script type="text/javascript" src="/libs/html5shiv/html5shiv.min.js"></script>
		<script type="text/javascript" src="/libs/html5shiv/html5shiv-printshiv.min.js"></script>
		<script type="text/javascript" src="/libs/respond/respond.min.js"></script>
	<![endif]-->

	<link href="//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet">
	<script type="text/javascript" src="/js/libs.js?6"></script>
	<script type="text/javascript" src="/js/common.js?6"></script>
</body>
</html>
